"""
creates list of tuples [(leaves,arrives), (leaves, arrives)...]
# 60 + takes is somewhat magic, we just need some overlap to adress buses thata the cross whole hour
"""
def depardie(inter, start, takes) = range(start,60+takes,inter) |> map$(x => (x, x+takes)) |> list


"""
finds sooner bus according to your needle
example: sooner found
#sooner([(47, 88), (50, 85), (59, 75)], (35, 76)) |> print # (59,75)

# example: sooner not found
# sooner([(11, 52), (20, 55), (23, 64), (35, 76), (35, 70), (47, 88), (50, 85), (59, 100)], (5, 40)) |> print  # (5,40)
"""
def sooner(da, needle):
    match da:
        case [tup] + tail if (tup[1] < needle[1]) and (tup[0] != needle[0]):
            return sooner(tail, tup)
        case [_] + tail:
            return sooner(tail, needle)
    return needle


"""
creates a list of letgo times
example: I should let go from 0:00 to 0:03 -> (0,3), 
WATCH OUT
from 00:54 to 01:03 -> (54,3) --- see preproces_hours
"""
def letgos(da, previous = (0,0), letgo = []):
    match da:
        case [tup] + tail:
            soon = sooner(tail, tup)
            if soon == tup:
                # there is no sooner, you should hop on now
                return letgos(tail, tup, letgo)
            else:
                # I should let this one go!
                tup = (tup[0] % 60, tup[1])
                return letgos(tail, tup, letgo + [(previous[0], tup[0])])

    return letgo


"""
converts tups to ranges
preprocess so that ranges are inclusive not exclusive 
deals with overlaps (54,3) -> (54,60) (hopefuly its enough)
"""
def preproces_hours(tup):
    match tup:
        case (a,b) if a > b:
            return range(tup[0]+1,60)
        case (a,b) if a == 0:
            return range(tup[0],tup[1]+1)
        case _:
            return range(tup[0]+1, tup[1] +1)

